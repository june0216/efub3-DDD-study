## 4.3.8 별도 테이블에 저장하는 밸류 매핑

- 하나의 애그리거트에서 루트 엔티티를 뺀 나머지 구성요소는 대부분 밸류이다.
- 독자적인 라이프 사이클을 갖는다면 구분되는 애그리거트일 가능성이 높다

  예를 들어 상품과 리뷰의 경우 같은 애그리거트라고 생각할 수 있는데 함께 생성되지 않고 함께 변경되지 않는다. 또한 변경 주체도 다르기 때문에 리뷰는 리뷰 애그리거트에 속한다.

- 애그리거트에 속한 객체가 밸류인지 엔티티인지 구분하는 방법
    - 고유 식별자를 갖는지 확인
    - 하지만 애그리거트의 고유 식별자와 테이블 PK는 다른 것이므로 찾각하지 말자
    - 예를 들어 아티클 데이틀의 데이터를 연결하기 위해 따로 아티클_content 테이블을 만들었다고 하자 이 테이블은 별도의 식별자가 필요하지 않다. → 게시글의 특정 프로퍼티를 별도의 테이블에 보관한 것이라고 접근해야 한다.
        - → @Embeddable로 매핑해야 한다.
        - @SecondaryTable과 @AttributeOverride를 사용해야 한다
            - @SecondaryTable = 두 테이블을  조인한다.
                - name = 벨류를 저장할 테이블 지정
                - pkjoinColumns = 밸류 테이블에서 엔티티 테이블로 조인할 때 사용할 컬럼을 지정한다.
    - 게시글 목록을 보여주는 화면은 article 테이블의 데이터만 필요하지, article_content 테이블의 데이터는 필요하지 않다.
        - @SecondaryTable 이를 사용하면 목록 화면에 보여줄 때 Article을 조회할 때 article_content 테이블까지 조인해서 테이터를 읽어오는데 이것을 원하는 결과가 아니다.
            - 이 문제를 해소하고자 articleContent를 엔티티로 매핑하고 Article에서 AricleContent로의 로딩을 지연로딩 방식으로 설정할 수 있다. ( 하지만 이 방식은 밸류인 모델을 엔티티로 만드는 것이므로 좋은 방법이 아니다) → 조회 전용 쿼리 사용

## 4.3.9 밸류 컬렉션을 @Entity로 매핑하기

- JPA는 @Embeddable 타이의 클래스 상속 매핑을 지원하지 않는다.
    - → @Entity를 이용해서 상속 매핑으로 처리해야 한다
        - 이때, 식별자 매핑을 위한 필드 추가, 구현 클래스를 구분하기 위한 타입 식별 칼럼 추가

      ex) Image를 상속 받은 클래스는 @Entity와 @Discriminator을 사용해서 매핑을 설정한다.

- 하이버네이트는 @Entity에 대한 delete와 @Embeddable 타입에 대한 컬렉션의 clear() 처리가 다르게 한다.
    - @Entity의 경우 select로 개별 엔티티를 로딩하고 각 개별 엔티티에 대해 delete쿼리를 실행한다. → 서비스 성능에 문제 생김
    - @Embeddable의 경우 컬렉션에 속한 객체를 로딩하지 않고 한 번의 delete 쿼리로 삭제 처리를 수행한다.
    - → 애그리거트 특성을 유지하면서 이 문제를 해소하려면 결국 상속을 포기하고 @Embeddable로 매핑된 단일 클래스로 구현해야 한다.

## 4.3.10 ID 참조와 조인 테이블을 이용한 단방향 M-N매핑

- 애그리거트 간 집합 연관은 성능 상의 이유로 피해야 한다. 하지만
    - ID 참조를 이용한 단방향 집합 연관을 적용해볼 수 있다.
- @ElmentCollection을 사용하기 때문에 애그리거트를 삭제할 때 매핑에 사용된 조인 테이블의 데이터도 함께 삭제된다.
    - 애그리거트를 직접 참조하는 방식이었다면 영속성 전파나 로딩 전략을 고민해야 하는데 id 참조 방식을 사용함으로써 이런 고민을 없앨 수 있다.

## 4.4 애그리거트 로딩 전략

JPA 매핑을 설정할 때 기억해야 할 점은 애그리거트에 속한 객체가 모두 모여야 완전한 하나가 된다는 것이다.

- 조회 시점에서 애그리거트를 완전한 상태가 되도록 하려면 애그리거트 루트에서 연관 매핑의 조회 방식을 즉시 로딩으로 설정하면 된다.
    - FetchType.EAGER
- 즉시 로딩 방식으로 설정하면 애그리거트 루트를 로딩하는 시점에 애그리거트에 속한 모든 객체를 함께 로딩할 수 있다는 장점이 있지만 항상 좋은 것은 아니다.
    - 특히, 컬렉션에 대해 로딩 전략을 FetchType.EAGER로 한다면 오히려 즉시 로딩 방식이 문제가 될 수 있다.
        - ex) 상품 애그리거트 루트가 @Entity로 구현한 Image와 @Embeddable로 구현한 Option 목록을 갖고 있다고 하자
        - 상품을 조회하면 하이버네이트는 상품을 위한 테이블, 이미지를 위한 테이블, Option을 위한 테이블을 조인한 쿼리를 실행한다.
            - → 카다시안 조인을 사용하기 때문에 쿼리 결과에 중복을 발생시킨다.
                - 하이버네이트가 중복된 데이터를 알맞게 제거해서 실제 메모리에는 1개의 상품 객체, 2개의 이미지, 2개의 OPTION객체로 변환해주지만, 애그리거트가 커지면 문제가 될 수 있다. (성능떨어짐)
    - ⇒ 애그리거트는 개념적으로 하나여야 한다. 하지만 루트 엔티티를 로딩하는 시점에 애그리거트에 속한 객체를 모두 로딩해야 하는 것은 아니다.
    - 애그리거트가 완전해야 하는 이유
        - 1) 상태를 변경하는 기능을 실행할 떄 애그리거트 상태가 완전해야 한다.
            - 상태 변경 기능을 실행하기 위해 조회 시점에 즉시 로딩을 이용해서 애그리거트를 완전한 상태로 로딩할 필요는 없다.
                - → JPA는 트랜잭션 범위 내에서 지연로딩을 허용하기 때문에 다음 코드처럼 실제로 상태를 변경하는 시점에 필요한 구성요소만 로딩해도 문제가 되지 않는다.
                - + 상태 변경 기능보다 조회 기능을 더 많이 사용하므로 추가 쿼리로 인한 실행 속도 저하는 문제가 되지 않는다.
        - 2) 표현 영역에서 애그리거트의 상태 정보를 보여줄 때 필요하기 때문
            - 별도의 조회 전용 기능과 모델을 구현하는 방식을 사용하는 것이 더 유리하기 때문에 완전한 로딩 문제는 1번의 이유와 좀 더 상관이 있다.


## 4.5 애그리거트의 영속성 전파

- 애그리거트가 완전한 상태여야 한다는 것은 애그리거트 루트를 조회할 때뿐만 아니라 `저장하고 삭제할 때`도 하나로 처리해야 함을 의미한다.

- 저장 메서드는 애그리거트 루트만 저장하면 안 되고 애그리거트에 속한 모든 객체를 저장해야 한다.
- 삭제 메서드는 애그리거트 루트뿐만 아니라 애그리거트에 속한 모든 객체를 삭제해야 한다.
- @Embeddable매핑 타입은 함께 저장되고 삭제 되므로 cascade 속성을 추가로 설정하지 않아도 된다.
- 반면, 애그리거트에 속한 @Entity 타입에 대한 매핑은 cascade속성을 사용해서 저장과 삭제 시에 함께 처리되도록 설정해야 한다.
    - OneToMany나 OneToOne은 속성 기본값이 없으므로 CascadeType.PERSIST, CascadeType.REMOVE를 설정한다.

## 4.6 식별자 생성 기능

- 식별자 생성 방식
    - 1) 사용자가 직접 생성
    - 2) 도메인 로직으로 생성
        - 식별자 생성 규칙이 있다면 엔티티를 생성할 떄 식별자를 엔티티가 별도 서비스로 식별자 기능을 분리해야 한다.
            - 식별자 생성 규칙은 도메인 규칙이므로 도메인 영역에 식별자 생성 기능을 위치시켜야 한다.
                - ex) ProductIdService → ProductService에서 주입받아 실행
            - 리포지터리에서 식별자를 생성하는 메서드 구현 가능
    - 3) db를 이용한 일련 번호 생성
        - @GeneratedValue 사용
        - DB의 insert쿼리를 실행해야 식별자가 생성되므로 도메인 객체를 리포지터리에 저장할 때 식별자가 생성된다.
            - ⇒ 도메인 객체를 생성하는 시점에 식별자를 알 수 없고 도메인 객체를 저장한 뒤에 식별자를 구할 수 있다.

## 4.7 도메인 구현과 DIP

- 다음은 DIP 에 위반된 것이다.
    - 1) @Entity, @Table, @Id 와 같은 어노테이션 사용
        - JPA에 특화된 애너테이션을 사용하므로 엔티티가 인프라인 JPA에 의존하는 것이다.
    - 2) JpaRepository상속해서 쓰기
        - ArticleRepository는 도메인 패키지 위에 있는데 이것이 JPA Repository를 상속했다는 의미는 도메인이 인프라에 의존한 것이다.
- 구현 기수에 대한 의존 없이 도메인을 순수하게 유지하려면 위의 2가지 모두 하지 않아야 한다.
    - 1) 애너테이션을 모두 지우고 인프라에 JPA 연동을 위한 클래스를 추가
    - 2) ArticleRepository를 도메인 위가 아닌 인프라에 위치시켜야 한다.